#### 堆内存

> 对象数据类型或者函数数据类型在定义的时候首相都会开辟一个堆内存  
> 堆内存有一个引用地址,如果外面有变量等知道了这个地址,那么这个地址就是被占用了,就不能被销毁了  

```javascript
var obj1 = {name:"lilei"};
var obj2 = obj2;

// null: 空对象指针
// 我们想要让堆内存释放/销毁,只需要把所有引用它的变量赋值为null即可,
// 如果当前的堆内存没有任何东西被占用,那么浏览器会在空闲的时候把它销毁
obj1 = null;
obj2 = null;
```

#### 栈内存

> 1. 全局作用域  
> 只有当页面关闭的时候全局作用域才会销毁  
>  
> 2. 私有作用域(只有函数执行会产生私有作用域)  
> 一般情况下,函数执行会形成一个新的私有作用域,当私有作用域中的代码执行完成后,当前作用域都会主动的释放和销毁  
> **特殊情况**:  
>   当前私有作用域中的部分内存被作用域外的东西占用了,那么当前的这个作用域就不能销毁了  

```javascript
// 函数执行返回了一个引用数据类型的值, 并且在函数的外面被一个其他的东西给接收了,
// 这种情况下一般形成的私有作用域都不会被销毁
function fn(){
    var num = 100;
    return function (){
        
    }
}
var f = fn(); // fn执行形成的这个私有作用域就不能再销毁了
```
```html
<!-- 在一个私有作用域中给dom元素的时间绑定方法, 一般情况下我们的私有作用域不销毁 -->
<div id="box"></div>
<script>
 var oBox = document.getElementById("box");
 ~function(){
     oBox.onclick = function(){
         
     }
 }(); // 当前自执行函数形成的私有作用域也不销毁
</script>
```
```javascript
// 下述情况属于不立即销毁 -> fn返回的函数没有别其他的东西占用, 但是还需要执行一次呢
// 所以暂时不销毁, 当返回的值执行完成后, 浏览器会在空闲的时候把它销毁了
function fn(){
    var num = 100;
    return function () {
        
    }
};
fn()(); // 首先执行fn, 返回一个小函数对应的内存地址, 然后紧接着让返回的小函数再执行
```
++ i 和 i ++  
都是自身累加1, 在和其他的值进行运算的时候有区别的  
i ++ :先拿i的值进行运算, 运算完成本身再+1  
++ i :先本身累加1 ,然后拿累加完成的结果去运算  

#### 作用域练习题

```javascript
function fn(){
    var i = 10;
    return function(n){
        console.log(n + (++i));
    }
}
var f = fn();
f(10); // 21
f(20); // 32
fn()(10); // 21
fn()(20); // 31
```
```javascript
function fn(i){
    return function(n){
        console.log(n + i++);
    }
}
var f = fn(13);
fn(12); // 25
fn(14); // 28
fn(15)(12); // 27
fn(16)(13); // 29
```
